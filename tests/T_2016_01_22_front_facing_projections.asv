close all;
clc;
D = 3;

%% Generate data
%[centers, radii, blocks] = get_random_convtriangle();
%[centers, radii, blocks] = get_random_convsegment(D);
[centers, radii, blocks] = get_random_convquad();

data_points = generate_depth_data_synthetic(centers, radii, blocks);

camera_ray = [0; 0; 1];
camera_center = [0; 0; 0];

%% Compute projections and normals
[model_indices, model_points, block_indices, axis_projections, is_best_projection] = compute_projections_front(data_points, centers, blocks, radii, camera_ray);
model_normals = compute_model_normals_temp(centers, blocks, radii, model_points, model_indices);
outline_indices = [];
for i = 1:length(model_points)
    if isempty(model_points{i}), continue; end
    if any(isnan(model_points{i})) || ~is_best_projection(i)
        outline_indices(end + 1) = i;
    end
end

%% Find outline
outline2D = find_planar_outline(centers, blocks, radii, false);
[outline] = find_3D_outline(centers, outline2D);

%% Project on outline
[outline_indices, outline_points] = ...
    compute_projections_outline(data_points(outline_indices), outline, centers, radii, camera_ray);

%% Compare t

%% Display
display_result(centers, data_points, model_points, blocks, radii, true, 0.8, 'small');

for i = 1:length(outline)
    if length(outline{i}.indices) == 2
        myline(outline{i}.start, outline{i}.end, 'y');
    else
        draw_circle_sector_in_plane(centers{outline{i}.indices}, radii{outline{i}.indices}, camera_ray, outline{i}.start, outline{i}.end, 'y');
    end
end

view([-180, -90]); camlight; drawnow;
